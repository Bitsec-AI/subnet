"""Tests for vulnerability status and related functionality."""
import json
from typing import List, Tuple, Dict, Any

import pytest

from bitsec.base.vulnerability_status import VulnerabilityStatus
from bitsec.base.vulnerability_category import VulnerabilityCategory
from bitsec.protocol import Vulnerability


@pytest.fixture
def sample_vulnerability() -> Tuple[Vulnerability, str]:
    """Fixture providing a sample vulnerability for testing.
    
    Returns:
        Tuple[Vulnerability, str]: A tuple containing (vulnerability, json_string).
    """
    v = Vulnerability(
      category=VulnerabilityCategory.WEAK_ACCESS_CONTROL,
      description="Miners could report false hardware specifications to appear more capable than they actually are, potentially receiving more allocation requests and rewards.",
      vulnerable_code="error",
      code_to_exploit="""
      # Claims 8 GPUs with 80GB each when actually having only 2 GPUs with 10GB each
      def get_gpu_info():
      return {
        'count': 8,
        'capacity': 80000,
        'details': [{'name': 'NVIDIA A100-SXM4-80GB'} for _ in range(8)]
      }""",
      rewritten_code_to_fix_vulnerability="# Implement hardware verification checks and cross-reference reported specs with actual performance"
    )
    return v, v.model_dump_json()


def test_vulnerability_status_sorting() -> None:
    """Test that VulnerabilityStatus instances can be properly sorted."""
    # Create an unsorted list of statuses
    unsorted_statuses: List[VulnerabilityStatus] = [
        VulnerabilityStatus.RESOLVED,
        VulnerabilityStatus.OPEN,
        VulnerabilityStatus.INVALID,
        VulnerabilityStatus.ACKNOWLEDGED
    ]
    
    # Sort the statuses
    sorted_statuses = sorted(unsorted_statuses)
    
    # Expected order based on numeric prefixes
    expected_order = [
        VulnerabilityStatus.OPEN,  # 10
        VulnerabilityStatus.ACKNOWLEDGED,  # 20
        VulnerabilityStatus.RESOLVED,  # 30
        VulnerabilityStatus.INVALID  # 40
    ]
    
    assert sorted_statuses == expected_order


def test_vulnerability_status_comparisons() -> None:
    """Test that VulnerabilityStatus comparison operators work correctly.
    
    Note: The comparison operators are implemented to support sorting by severity/priority,
    where OPEN (10) is considered highest priority and thus sorts first, followed by
    ACKNOWLEDGED (20), RESOLVED (30), and INVALID (40). This ordering helps in displaying
    and processing vulnerabilities in a priority-based sequence.
    """
    # Test less than
    assert VulnerabilityStatus.OPEN < VulnerabilityStatus.ACKNOWLEDGED
    assert VulnerabilityStatus.ACKNOWLEDGED < VulnerabilityStatus.RESOLVED
    assert VulnerabilityStatus.RESOLVED < VulnerabilityStatus.INVALID
    
    # Test greater than
    assert VulnerabilityStatus.INVALID > VulnerabilityStatus.RESOLVED
    assert VulnerabilityStatus.RESOLVED > VulnerabilityStatus.ACKNOWLEDGED
    assert VulnerabilityStatus.ACKNOWLEDGED > VulnerabilityStatus.OPEN


def test_vulnerability_status_json_serialization(sample_vulnerability: Tuple[Vulnerability, str]) -> None:
    """Test that VulnerabilityStatus can be properly serialized to and from JSON."""
    vuln, json_str = sample_vulnerability
    
    # Test deserialization
    loaded_data = json.loads(json_str)
    
    # Verify the full vulnerability structure
    assert loaded_data["category"] == VulnerabilityCategory.WEAK_ACCESS_CONTROL.value
    assert loaded_data["description"] == vuln.description
    assert loaded_data["vulnerable_code"] == vuln.vulnerable_code
    assert loaded_data["code_to_exploit"] == vuln.code_to_exploit
    assert loaded_data["rewritten_code_to_fix_vulnerability"] == vuln.rewritten_code_to_fix_vulnerability


def test_vulnerability_status_tuple_conversion(sample_vulnerability: Tuple[Vulnerability, str]) -> None:
    """Test that VulnerabilityStatus can be converted to and from tuples."""
    vuln, json_str = sample_vulnerability
    # Create a tuple from the vulnerability data with a status
    status = VulnerabilityStatus.OPEN
    vuln_tuple = (
        str(status.value),
        vuln.description,
        vuln.category.value
    )
    
    # Convert from tuple
    parsed_status = VulnerabilityStatus.from_string(vuln_tuple[0])
    assert parsed_status == VulnerabilityStatus.OPEN
    
    # Convert back to tuple-compatible string
    assert str(parsed_status) == "10 open"
    
    # Test creating new tuple with status
    new_tuple = (str(status), "new description", "new category")
    assert new_tuple[0] == "10 open"


def test_vulnerability_default_values(sample_vulnerability: Tuple[Vulnerability, str]) -> None:
    """Test that default values are correctly applied when creating vulnerabilities."""
    # When status is not provided, it should default to OPEN
    default_status = VulnerabilityStatus.get_default_status()
    assert default_status == VulnerabilityStatus.OPEN
    
    # Verify the default status value
    assert default_status.value == "10 open"
    
    # Test that the default status sorts first
    all_statuses = list(VulnerabilityStatus)
    assert sorted(all_statuses)[0] == default_status


def test_vulnerability_status_from_invalid_string() -> None:
    """Test that from_string handles invalid inputs gracefully."""
    # Test with invalid string
    assert VulnerabilityStatus.from_string("invalid_status") is None
    
    # Test with empty string
    assert VulnerabilityStatus.from_string("") is None
    
    # Test with None
    assert VulnerabilityStatus.from_string(None) is None


def test_vulnerability_status_case_insensitive() -> None:
    """Test that status string matching is case insensitive."""
    # Test various case combinations
    assert VulnerabilityStatus.from_string("10 OPEN") == VulnerabilityStatus.OPEN
    assert VulnerabilityStatus.from_string("10 open") == VulnerabilityStatus.OPEN
    assert VulnerabilityStatus.from_string("10 OpEn") == VulnerabilityStatus.OPEN